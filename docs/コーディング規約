# 🛡️ OshiQuest Development Guidelines

OshiQuestプロジェクトにおける、パフォーマンスとメンテナンス性を最大化するための開発ガイドライン（コーディング規約）です。
開発時は常にこのリストを参照し、準拠してください。

## 1. パフォーマンス最適化 (Tree Awareness)

Flutterの描画パイプライン（Widget -> Element -> RenderObject）を意識し、無駄な再構築を防ぐことを最優先します。

* **`const` コンストラクタを必須とする**
    * 静的なWidget（テキスト、アイコン、スペーシング、スタイル定義など）には必ず `const` を付与してください。
    * `const` インスタンスはメモリ上で再利用され、Elementの更新処理（リビルド）がスキップされるため、パフォーマンスへの貢献度が非常に高いです。
    * *Bad:* `Text('Hello')`
    * *Good:* `const Text('Hello')`

* **Widgetツリーの再構築を最小限にする**
    * 無駄なリビルドは、CPU（Elementの差分検知）とGPU（RenderObjectの描画）の両方に負荷をかけるため、徹底して避けてください。

## 2. リビルドの抑制 (Build Scope)

* **Widgetを小さく切り出す**
    * 巨大な `build` メソッドを作らず、意味のある単位でクラス（Widget）として抽出してください。
    * 抽出したWidgetに `const` コンストラクタを定義することで、親がリビルドされてもその部分はスキップ可能になります。
    * *Note:* 関数（Helper Method）での切り出しではなく、クラス（StatelessWidgetなど）での切り出しを推奨します。

* **Riverpodの監視を最適化する**
    * `ref.watch` する際は、必要な値だけを監視してください。関係のないデータの変更で画面全体が再描画されないようにします。
        * *例:* `ref.watch(provider.select((s) => s.value))`
    * `ref.read` はイベントハンドラ内（ボタン押下時など）でのみ使用し、`build` メソッド内での値取得には原則使用しないでください。

## 3. ステート管理 (State Management)

* **`StatelessWidget` (または `ConsumerWidget`) を優先する**
    * 状態を持たないUIパーツは、可能な限りStatelessにしてください。

* **ローカルな状態とグローバルな状態を区別する**
    * **ローカル状態:** 画面固有のUI状態（タブのインデックス、フォームの入力中テキスト、アニメーションなど）は `StatefulWidget` (`ConsumerStatefulWidget`) で管理して構いません。
    * **グローバル状態:** アプリ全体で共有すべきデータ（ユーザー情報、所持アイテム、習慣リストなど）は Riverpod で管理してください。

## 4. アーキテクチャとコード品質

* **UIロジックとビジネスロジックの分離**
    * 複雑な処理、DB操作、データ加工は `Logic` 層（Controller / Repository）に記述し、UI（`build` メソッド）には記述しないでください。
    * UIは「状態を表示すること」と「ユーザー入力をControllerに渡すこと」に専念してください。

* **静的解析 (Linter) に従う**
    * `prefer_const_constructors` などの警告はパフォーマンスに関わる重要な指摘であるため、無視せずに修正してください。